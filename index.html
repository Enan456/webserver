<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enan - Digital Architect</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0f0f1a;
            overflow: hidden;
            font-family: 'Orbitron', monospace;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #sandCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transition: opacity 0.5s ease;
        }


        #orbCanvas {
            position: absolute;
            bottom: 50px; /* Shifted down */
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            height: 500px;
            z-index: 3;
            cursor: crosshair;
        }

        .content {
            position: absolute;
            top: 80px;
            left: 50%;
            z-index: 2;
            color: #ffffff;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transform: translate(-50%, -20px);
            transition: opacity 1.5s ease, transform 1.5s ease;
        }
        
        .content.visible {
            opacity: 1;
            transform: translateX(-50%);
        }

        h1 {
            font-size: 4rem;
            font-weight: 900;
            text-shadow: none;
            letter-spacing: 0.2em;
            margin-bottom: 20px;
            animation: letterSpacing 4s ease-in-out infinite;
        }

        .tagline {
            font-size: 1.2rem;
            color: #ffffff;
            text-shadow:
                0 0 5px #ffffff,
                0 0 10px #ffffff;
            letter-spacing: 0.1em;
            height: 1.5em;
            position: relative;
        }
        
        @keyframes letterSpacing {
            0%, 100% { letter-spacing: 0.2em; }
            50% { letter-spacing: 0.25em; }
        }

        .nav-links {
            position: absolute;
            bottom: 20px; /* Shifted down */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            z-index: 5;
            pointer-events: all;
            opacity: 0;
            transition: opacity 1.5s ease;
        }

        .nav-links.visible {
            opacity: 1;
        }

        .nav-links a {
            color: #ffffff;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            position: relative;
        }

        .nav-links a::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, #ffffff, #cccccc);
            transition: width 0.3s ease;
        }

        .nav-links a:hover {
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff;
        }

        .nav-links a:hover::after {
            width: 100%;
        }

        /* Scanline effect */
        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(180deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            animation: scanline 8s linear infinite;
            pointer-events: none;
            z-index: 3;
        }

        .info-panel {
            position: absolute;
            bottom: 150px; /* Shifted down */
            color: #fff;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 5;
            display: flex;
            width: 100%;
            justify-content: space-between;
            padding: 0 50px;
        }

        .info-panel.visible {
            opacity: 1;
        }

        .left-panel, .right-panel, .center-panel {
            width: 45%;
        }
        
        .center-panel {
            text-align: center;
            width: 100%;
        }

        .right-panel {
            text-align: right;
        }
        
        .info-panel p {
            margin: 5px 0;
            font-size: 0.9rem;
            letter-spacing: 0.1em;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }

            .tagline {
                font-size: 1rem;
            }

            #orbCanvas {
                bottom: 200px; /* Shifted down */
                transform: translateX(-50%) scale(0.7);
            }

            .nav-links {
                bottom: 150px; /* Shifted down */
                gap: 15px;
                flex-wrap: wrap;
                justify-content: center;
                width: 90%;
            }

            .nav-links a {
                font-size: 0.8rem;
            }

            .info-panel {
                bottom: 400px; /* Shifted down */
                flex-direction: column;
                align-items: center;
                padding: 0 20px;
            }

            .info-panel .left-panel,
            .info-panel .right-panel,
            .info-panel .center-panel {
                width: 100%;
                text-align: center;
                margin-bottom: 1em;
            }
        }
    </style>
</head>
<body>
    <canvas id="sandCanvas"></canvas>
    <canvas id="orbCanvas"></canvas>
    <div class="scanline"></div>

    <div class="content">
        <h1>ENAN</h1>
        <p class="tagline">
            DATA SCIENTIST, OPERATOR
        </p>
    </div>

    <div id="infoPanels">
         <div id="aboutInfo" class="info-panel">
            <div class="right-panel">
                <p>If you want to build cool stuff, hit me up.</p>
            </div>
        </div>
        <div id="workInfo" class="info-panel">
            <div class="left-panel">
                <p>Forward Deployed Engineer at Crowe</p>
				                 <p style="margin-top: 2em;"> </p>
                <p style="margin-top: 2em;">Chief Operating Officer at A Cubed Designs</p>
            </div>
            <div class="right-panel">
                <p>Server Admin/Owner American Institutional Methodology (AIM) Lab</p>
                 <p style="margin-top: 2em;"> </p>
				                 <p style="margin-top: 2em;"> </p>
                 <p>Data Science Mentor with The Erdos Institute</p>
            </div>
        </div>
        <div id="skillsInfo" class="info-panel">
            <div class="left-panel">
                <p>Design Thinking</p>
                <p>Business Management</p>
                <p>Insurance</p>
                <p>Nonprofit Consulting</p>
            </div>
             <div class="right-panel">
                <p>Python, AWS, GCP, R Shiny, Java</p>
                <p>JavaScript, SQL, Git, Firebase, HTML5, Bash, CSS</p>
            </div>
        </div>
        <div id="contactInfo" class="info-panel">
            <div class="left-panel">
                <p>630-608-3688</p>
            </div>
            <div class="right-panel">
                <p>contact@enan.dev</p>
            </div>
        </div>
         <div id="githubInfo" class="info-panel">
            <div class="right-panel">
                <p>https://github.com/Enan456</p>
            </div>
        </div>
         <div id="linkedinInfo" class="info-panel">
            <div class="right-panel">
                <p>https://www.linkedin.com/in/enan-srivastava/</p>
            </div>
        </div>
    </div>

    <div class="nav-links" id="navLinks">
        <a href="#about" data-section="1">ABOUT</a>
        <a href="#work" data-section="2">WORK</a>
        <a href="#skills" data-section="3">SKILLS</a>
        <a href="mailto:contact@enan.dev" target="_blank" data-section="5">CONTACT</a>
        <a href="https://github.com/Enan456" target="_blank" data-section="6">GITHUB</a>
        <a href="https://www.linkedin.com/in/enan-srivastava/" target="_blank" data-section="7">LINKEDIN</a>
    </div>

    <script>
        // Synthwave color palette
        const palette = [
            '#ff007f', // 0: Hot pink - ABOUT
            '#ff00ff', // 1: Magenta - WORK
            '#00ff00', // 2: Neon green - SKILLS
            '#00ffff', // 3: Cyan - (Unused Link)
            '#ffff00', // 4: Yellow - CONTACT
            '#ff8800', // 5: Orange - GITHUB
            '#00a2ff'  // 6: Blue - LINKEDIN
        ];

        const sandCanvas = document.getElementById('sandCanvas');
        const sandCtx = sandCanvas.getContext('2d');
        sandCanvas.width = window.innerWidth;
        sandCanvas.height = window.innerHeight;

        const orbCanvas = document.getElementById('orbCanvas');
        const orbCtx = orbCanvas.getContext('2d');
        orbCanvas.width = 500;
        orbCanvas.height = 500;
        
        const particleLayers = [
            { particles: [], count: 500, size: 1 },
            { particles: [], count: 700, size: 1 },
            { particles: [], count: 300, size: 1.5 }
        ];

        const settledParticles = [];
        const heightMap = new Array(sandCanvas.width).fill(sandCanvas.height);
        const orbDustParticles = [];
        const textDustParticles = [];
        const navLinkDustParticles = [];


        let mouseX = 0;
        let mouseY = 0;
        const SNOW_SPEED = 0.2;
        let orbRect; // To hold orb position dynamically


        class SandParticle {
            constructor(layer) {
                this.layer = layer;
                this.reset();
            }

            update() {
                this.y += SNOW_SPEED * this.speedMultiplier; 
                this.x += this.vx;

                const dx = this.x - mouseX;
                const dy = this.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 100) {
                    const force = (100 - dist) / 100;
                    this.x += (dx / dist) * force * 1.5;
                    this.y += (dy / dist) * force * 0.5;
                }

                const xPos = Math.floor(this.x);
                if (xPos >= 0 && xPos < sandCanvas.width && this.y >= heightMap[xPos] - this.layer.size) {
                    this.settle(xPos);
                    return;
                }

                if (this.y > sandCanvas.height + 10) {
                    this.reset();
                }
            }

            settle(xPos) {
                 let finalX = xPos;
                 let landingY = heightMap[xPos];

                for (let i = 0; i < 5; i++) {
                    let moved = false;
                    const checkLeft = finalX > 0 && heightMap[finalX - 1] > landingY + 1;
                    const checkRight = finalX < sandCanvas.width - 1 && heightMap[finalX + 1] > landingY + 1;

                    if (checkLeft && (!checkRight || Math.random() < 0.5)) {
                        finalX--;
                        landingY = heightMap[finalX];
                        moved = true;
                    } else if (checkRight) {
                        finalX++;
                        landingY = heightMap[finalX];
                        moved = true;
                    }
                    
                    if (!moved) break;
                }

                heightMap[finalX] -= this.layer.size;

                settledParticles.push({
                    x: finalX,
                    y: heightMap[finalX],
                    color: this.color,
                    size: this.layer.size
                });

                if (settledParticles.length > 30000) {
                    settledParticles.splice(0, 100);
                }
                this.reset();
            }

            reset() {
                this.x = Math.random() * sandCanvas.width;
                this.y = -Math.random() * 50 - 10;
                this.vx = 0; 
                this.vy = 0;
                
                if (Math.random() < 0.2) { // 20% chance for a grey particle
                    const greyValue = Math.floor(80 + Math.random() * 80);
                    const alpha = 0.4 + Math.random() * 0.3;
                    this.color = `rgba(${greyValue}, ${greyValue}, ${greyValue}, ${alpha})`;
                    this.brightness = 0.3 + Math.random() * 0.4; // Make them slightly dimmer/slower
                } else {
                    this.brightness = 0.4 + Math.random() * 0.6;
                    const colorValue = Math.floor(150 + 105 * this.brightness);
                    const alpha = this.brightness * 0.7;
                    this.color = `rgba(${colorValue}, ${colorValue}, ${colorValue}, ${alpha})`;
                }
                
                this.speedMultiplier = 0.5 + this.brightness;
            }

            draw() {
                sandCtx.fillStyle = this.color;
                sandCtx.fillRect(this.x, this.y, this.layer.size, this.layer.size);
            }
        }
        
        particleLayers.forEach(layer => {
            for (let i = 0; i < layer.count; i++) {
                layer.particles.push(new SandParticle(layer));
            }
        });

        class GustParticle {
             constructor(targetX, targetY, isTextParticle = false) {
                this.isTextParticle = isTextParticle;
                this.screenX = -200 + Math.random() * 150;
                this.screenY = Math.random() * window.innerHeight;
                this.targetX = targetX;
                this.targetY = targetY;
                this.gustPhase = true;
                this.gustSpeed = 5 + Math.random() * 5;
                this.z = (Math.random() - 0.5) * 40;
                this.size = 1.5;
                this.opacity = 0.7 + Math.random() * 0.3;
                this.life = 1.0;
                this.startTime = Date.now() + Math.random() * 200; 


                if (!isTextParticle) {
                    this.baseX = targetX;
                    this.baseY = targetY;
                    this.baseZ = this.z;
                    this.angle = Math.random() * Math.PI * 2;
                    this.speed = 0.005 + Math.random() * 0.01;
                }
            }

            update() {
                if(Date.now() < this.startTime) return;

                if (this.gustPhase) {
                    const dx = this.targetX - this.screenX;
                    const dy = this.targetY - this.screenY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > this.gustSpeed) {
                        this.screenX += (dx / distance) * this.gustSpeed;
                        this.screenY += (dy / distance) * this.gustSpeed;
                        this.screenX += Math.sin(Date.now() * 0.01 + this.screenY * 0.02) * 1.5;
                        this.screenY += Math.cos(Date.now() * 0.01 + this.screenX * 0.02) * 1.5;
                    } else {
                        this.screenX = this.targetX;
                        this.screenY = this.targetY;
                        this.gustPhase = false;
                         if (this.isTextParticle) {
                            return;
                        }
                        // Convert screen coordinates to local orb canvas coordinates
                        this.x = this.targetX - orbRect.left;
                        this.y = this.targetY - orbRect.top;
                        this.baseX = this.x;
                        this.baseY = this.y;
                    }
                } else if (this.isTextParticle) {
                    this.life -= 0.02;
                    if (this.life < 0) this.life = 0;

                } else { // Orb particle logic
                    this.angle += this.speed;

                    const spiralTime = orbTime * 0.2;
                    const distanceFromCenter = Math.sqrt((this.baseX - 250) ** 2 + (this.baseY - 250) ** 2);
                    const currentAngle = Math.atan2(this.baseY - 250, this.baseX - 250);

                    const spiralSpeed = 0.5;
                    const spiralTightness = 0.1;
                    const spiralAngle = currentAngle + spiralTime * spiralSpeed;
                    const spiralRadius = Math.min(220, distanceFromCenter * (1 + Math.sin(spiralTime + currentAngle * 3) * spiralTightness));

                    this.x = 250 + Math.cos(spiralAngle) * spiralRadius + Math.cos(this.angle) * 2;
                    this.y = 250 + Math.sin(spiralAngle) * spiralRadius + Math.sin(this.angle) * 2;
                    this.z = this.baseZ + Math.sin(this.angle * 0.4 + spiralTime) * 1.5;
                }
            }

            draw() {
                const scale = 1 + this.z * 0.005;
                let projectedSize = this.size * scale;
                const depth = Math.max(0.3, 1 - Math.abs(this.z) * 0.01);

                if (this.isTextParticle) {
                    if (this.life <= 0) return;
                    projectedSize = this.gustPhase ? projectedSize : projectedSize * this.life;
                    const opacity = this.opacity * depth * this.life;
                    sandCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    sandCtx.fillRect(this.screenX - projectedSize / 2, this.screenY - projectedSize / 2, projectedSize, projectedSize);
                } else if (this.gustPhase) {
                    sandCtx.fillStyle = `rgba(255, 255, 255, ${this.opacity * depth})`;
                    sandCtx.fillRect(this.screenX - projectedSize / 2, this.screenY - projectedSize / 2, projectedSize, projectedSize);
                } else { // Orb particle on orb canvas
                    orbCtx.fillStyle = this.color || `rgba(255, 255, 255, ${this.opacity * depth})`;
                    orbCtx.fillRect(this.x - projectedSize / 2, this.y - projectedSize / 2, projectedSize, projectedSize);
                }
            }
        }

        function createOrbDust() {
            orbDustParticles.length = 0;
            const centerX = 250;
            const centerY = 250;
            const orbParticles = 2500;

            for (let i = 0; i < orbParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 220;
                const localX = centerX + Math.cos(angle) * radius;
                const localY = centerY + Math.sin(angle) * radius;
                // Calculate target screen position based on dynamic orb position
                const screenX = orbRect.left + localX;
                const screenY = orbRect.top + localY;
                
                const particle = new GustParticle(screenX, screenY);
                orbDustParticles.push(particle);
            }
        }

        function createTextDust() {
            textDustParticles.length = 0; 
            const textParticleCount = 1200;
            const textRectWidth = 400;
            const textRectHeight = 100;
            const rectX = (window.innerWidth / 2) - (textRectWidth / 2);
            const rectY = 80;

            for (let i = 0; i < textParticleCount; i++) {
                const targetX = rectX + Math.random() * textRectWidth;
                const targetY = rectY + Math.random() * textRectHeight;
                const particle = new GustParticle(targetX, targetY, true);
                textDustParticles.push(particle);
            }
        }
        
         function createNavLinkDust() {
            navLinkDustParticles.length = 0;
            const navLinks = document.querySelectorAll('.nav-links a');
            navLinks.forEach(link => {
                const rect = link.getBoundingClientRect();
                const sampling = 3; 
                for (let y = rect.top; y < rect.bottom; y += sampling) {
                    for (let x = rect.left; x < rect.right; x += sampling) {
                        if (Math.random() > 0.5) { 
                            const particle = new GustParticle(x, y, true);
                            navLinkDustParticles.push(particle);
                        }
                    }
                }
            });
        }

        let orbTime = 0;
        let hoveredSection = -1;
        let introAnimationComplete = false;
        
        const aboutInfo = document.getElementById('aboutInfo');
        const workInfo = document.getElementById('workInfo');
        const skillsInfo = document.getElementById('skillsInfo');
        const contactInfo = document.getElementById('contactInfo');
        const githubInfo = document.getElementById('githubInfo');
        const linkedinInfo = document.getElementById('linkedinInfo');
        const allInfoPanels = [aboutInfo, workInfo, skillsInfo, ,contactInfo, githubInfo, linkedinInfo]; // Note the empty slot for section 3

        function updateInfoPanels(sectionIndex) {
            allInfoPanels.forEach(panel => {
               if(panel) panel.classList.remove('visible');
               if(panel) panel.style.color = '';
            });

            let panelToShow = null;
            // The sections are 0-indexed here from the orb calculation
            switch (sectionIndex) {
                case 0: panelToShow = aboutInfo; break;
                case 1: panelToShow = workInfo; break;
                case 2: panelToShow = skillsInfo; break;
                case 4: panelToShow = contactInfo; break;
                case 5: panelToShow = githubInfo; break;
                case 6: panelToShow = linkedinInfo; break;
            }

            if (panelToShow) {
                panelToShow.classList.add('visible');
                const activeColor = palette[sectionIndex];
                panelToShow.style.color = activeColor;
            }
        }


        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        orbCanvas.addEventListener('mousemove', (e) => {
            const rect = orbCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 250;
            const y = e.clientY - rect.top - 250;
            const angle = Math.atan2(y, x);
            const distance = Math.sqrt(x * x + y * y);
            let currentSection = -1;

            if (distance < 220) {
                let normalizedAngle = angle + Math.PI / 2 + (Math.PI * 2 / 7) / 2;
                if (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                const sectionSize = (Math.PI * 2) / 7;
                currentSection = Math.floor(normalizedAngle / sectionSize);
            }
            
            if(hoveredSection !== currentSection) {
                hoveredSection = currentSection;
                updateInfoPanels(hoveredSection);
                document.querySelectorAll('.nav-links a').forEach(link => {
                    // data-section is 1-based, orb is 0-based with gaps
                    const linkDataSection = parseInt(link.dataset.section, 10);
                    const linkSectionMap = {1:0, 2:1, 3:2, 5:4, 6:5, 7:6};
                    const linkSection = linkSectionMap[linkDataSection];

                    if (linkSection === hoveredSection) {
                        link.style.color = palette[hoveredSection];
                        link.style.textShadow = `0 0 10px ${palette[hoveredSection]}`;
                    } else {
                        link.style.color = '#ffffff';
                        link.style.textShadow = 'none';
                    }
                });
            }
        });

        orbCanvas.addEventListener('mouseleave', () => {
             if (hoveredSection !== -1) {
                hoveredSection = -1;
                updateInfoPanels(hoveredSection);
                 document.querySelectorAll('.nav-links a').forEach(link => {
                    link.style.color = '#ffffff';
                    link.style.textShadow = 'none';
                });
            }
        });
        
        document.querySelectorAll('.nav-links a').forEach(link => {
            const linkDataSection = parseInt(link.dataset.section, 10);
            const linkSectionMap = {1:0, 2:1, 3:2, 5:4, 6:5, 7:6};
            const section = linkSectionMap[linkDataSection];

            link.addEventListener('mouseenter', () => {
                hoveredSection = section;
                updateInfoPanels(section);
                 document.querySelectorAll('.nav-links a').forEach(innerLink => {
                    const innerLinkDataSection = parseInt(innerLink.dataset.section, 10);
                    const innerLinkSection = linkSectionMap[innerLinkDataSection];
                     if (innerLinkSection === section) {
                        innerLink.style.color = palette[section];
                        innerLink.style.textShadow = `0 0 10px ${palette[section]}`;
                     } else {
                        innerLink.style.color = '#ffffff';
                        innerLink.style.textShadow = 'none';
                     }
                 });
            });
            link.addEventListener('mouseleave', () => {
                hoveredSection = -1;
                updateInfoPanels(-1);
                document.querySelectorAll('.nav-links a').forEach(l => {
                    l.style.color = '#ffffff';
                    l.style.textShadow = 'none';
                });
            });
        });

        function animate() {
            sandCtx.clearRect(0, 0, sandCanvas.width, sandCanvas.height);
            orbCtx.clearRect(0, 0, 500, 500);

            orbTime += 0.01;

            if (!introAnimationComplete && textDustParticles.length > 0 && navLinkDustParticles.length > 0) {
                const flyingParticles = [...textDustParticles, ...navLinkDustParticles, ...orbDustParticles].filter(p => p.gustPhase);
                
                // Start fading in the text when most particles are close to their destination.
                if (flyingParticles.length < 400) {
                    document.querySelector('.content').classList.add('visible');
                    document.querySelector('.nav-links').classList.add('visible');
                    introAnimationComplete = true;
                }
            }

            particleLayers.forEach(layer => {
                layer.particles.forEach(p => {
                    p.update();
                    p.draw();
                });
            });

            settledParticles.forEach(p => {
                sandCtx.fillStyle = p.color;
                sandCtx.fillRect(p.x, p.y, p.size, p.size);
            });
            
            orbDustParticles.forEach(particle => {
                particle.update();
                particle.draw();
            });
             textDustParticles.forEach(particle => {
                particle.update();
                particle.draw();
            });
             navLinkDustParticles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            orbDustParticles.forEach(particle => {
                if (!particle.gustPhase) {
                    // Add a chance for particles to be grey
                    if (Math.random() < 0.35) {
                        const greyValue = 120 + Math.random() * 80;
                        particle.color = `rgba(${greyValue}, ${greyValue}, ${greyValue}, 0.6)`;
                        return; // Skip the color section logic for this particle
                    }

                    const distanceFromCenter = Math.sqrt((particle.x - 250)**2 + (particle.y - 250)**2);
                    const pRelativeX = (particle.x - 250) / 220;
                    const pRelativeY = (particle.y - 250) / 220;
                    
                    const angle = Math.atan2(pRelativeY, pRelativeX);
                    let normalizedAngle = angle + Math.PI / 2 + (Math.PI * 2 / 7) / 2;

                    // Add a sine wave distortion for a wavy effect
                    const waveAmount = 0.2;
                    const waveFrequency = 0.05;
                    normalizedAngle += Math.sin(distanceFromCenter * waveFrequency + orbTime * 3) * waveAmount;
                    
                    if (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                    if (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                    
                    const sectionSize = (Math.PI * 2) / 7;
                    const sectionIndex = Math.floor(normalizedAngle / sectionSize);

                    particle.color = palette[sectionIndex] + 'A0';
                }
            });

            requestAnimationFrame(animate);
        }

        function updateOrbPosition() {
             orbRect = orbCanvas.getBoundingClientRect();
        }

        function reinitializeParticles() {
            updateOrbPosition();
            createOrbDust();
            createTextDust();
            createNavLinkDust();
        }

        window.addEventListener('resize', () => {
            sandCanvas.width = window.innerWidth;
            sandCanvas.height = window.innerHeight;
            
            heightMap.length = sandCanvas.width;
            heightMap.fill(sandCanvas.height);
            settledParticles.length = 0;
            
            reinitializeParticles();
        });

        document.addEventListener('DOMContentLoaded', () => {
            reinitializeParticles();
        });

        animate();

    </script>
</body>
</html>

